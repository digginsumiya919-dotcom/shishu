<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>实数构造：对称性与等价类</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #0a0a0f;
    color: #e0e0e0;
    font-family: 'Georgia', serif;
    overflow: hidden;
    height: 100vh;
  }
  #canvas { display: block; }
  #ui {
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    pointer-events: none;
  }
  #title {
    position: fixed;
    top: 24px; left: 32px;
    pointer-events: none;
  }
  #title h1 {
    font-size: 14px;
    letter-spacing: 3px;
    color: #888;
    text-transform: uppercase;
    font-weight: normal;
  }
  #title h2 {
    font-size: 22px;
    color: #ddd;
    font-weight: normal;
    margin-top: 4px;
  }
  #controls {
    position: fixed;
    bottom: 32px; left: 32px;
    pointer-events: all;
    display: flex;
    flex-direction: column;
    gap: 8px;
  }
  button {
    background: rgba(255,255,255,0.05);
    border: 1px solid rgba(255,255,255,0.15);
    color: #bbb;
    padding: 8px 16px;
    font-size: 12px;
    letter-spacing: 1px;
    cursor: pointer;
    transition: all 0.2s;
    font-family: inherit;
  }
  button:hover, button.active {
    background: rgba(255,255,255,0.12);
    color: #fff;
    border-color: rgba(255,255,255,0.4);
  }
  #legend {
    position: fixed;
    bottom: 32px; right: 32px;
    font-size: 11px;
    color: #666;
    line-height: 2;
    text-align: right;
  }
  #legend span {
    display: inline-block;
    width: 8px; height: 8px;
    border-radius: 50%;
    margin-right: 6px;
    vertical-align: middle;
  }
  #info {
    position: fixed;
    top: 50%; right: 32px;
    transform: translateY(-50%);
    font-size: 12px;
    color: #555;
    line-height: 2;
    text-align: right;
    max-width: 200px;
  }
  #info.visible { color: #888; }
</style>
</head>
<body>
<canvas id="canvas"></canvas>

<div id="title">
  <h1>基于对称性的</h1>
  <h2>实数构造</h2>
</div>

<div id="controls">
  <button id="btn-spiral" class="active" onclick="setMode('spiral')">螺旋结构</button>
  <button id="btn-mirror" onclick="setMode('mirror')">镜像结构</button>
  <button id="btn-zero" onclick="setMode('zero')">零的对称性</button>
  <button id="btn-number" onclick="setMode('number')">一个数的折线</button>
  <button id="btn-equiv" onclick="setMode('equiv')">等价类·旋转</button>
</div>

<div id="legend">
  <div><span style="background:#4488ff"></span>镜外折线（正）</div>
  <div><span style="background:#ff4466"></span>镜内折线（负）</div>
  <div><span style="background:#44ffaa"></span>零（对称）</div>
  <div><span style="background:#ffaa44"></span>痣（标记层）</div>
</div>

<div id="info"></div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
let W, H, cx, cy;
let mode = 'spiral';
let t = 0;
let animId;

function resize() {
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight;
  cx = W / 2;
  cy = H / 2;
}
resize();
window.addEventListener('resize', resize);

function setMode(m) {
  mode = m;
  document.querySelectorAll('button').forEach(b => b.classList.remove('active'));
  document.getElementById('btn-' + m).classList.add('active');
  updateInfo(m);
}

function updateInfo(m) {
  const info = document.getElementById('info');
  const texts = {
    spiral: '外层权重大\n关系的关系\n具有更高抽象层级\n\nw(n) = 4^(n-1)',
    mirror: '每个数 =\n镜外折线 + 镜内折线\n\n若重叠则为零',
    zero: '零不是"空"\n零是完美对称\n\n有无穷多个零\n所有对称折线',
    number: '一个数 = 痣的模式\n\n● 负大（有痣）\n○ 正大（无痣）\n\n数值 = Σ w(i)×●(i)',
    equiv: '镜内外同时旋转\n相对关系不变\n数值不变\n\n一个数 = 等价类\n= 所有同步旋转\n的折线对\n\n冗余是对称性\n的必然要求'
  };
  info.innerHTML = texts[m].replace(/\n/g, '<br>');
  info.className = 'visible';
}

// ── 绘制工具 ──
function clear() {
  ctx.fillStyle = '#0a0a0f';
  ctx.fillRect(0, 0, W, H);
}

function circle(x, y, r, color, fill=false, alpha=1) {
  ctx.save();
  ctx.globalAlpha = alpha;
  ctx.beginPath();
  ctx.arc(x, y, r, 0, Math.PI * 2);
  if (fill) {
    ctx.fillStyle = color;
    ctx.fill();
  } else {
    ctx.strokeStyle = color;
    ctx.lineWidth = 1;
    ctx.stroke();
  }
  ctx.restore();
}

function line(x1, y1, x2, y2, color, width=1, alpha=1) {
  ctx.save();
  ctx.globalAlpha = alpha;
  ctx.strokeStyle = color;
  ctx.lineWidth = width;
  ctx.beginPath();
  ctx.moveTo(x1, y1);
  ctx.lineTo(x2, y2);
  ctx.stroke();
  ctx.restore();
}

function text(str, x, y, color='#888', size=11, align='center') {
  ctx.save();
  ctx.fillStyle = color;
  ctx.font = `${size}px Georgia`;
  ctx.textAlign = align;
  ctx.fillText(str, x, y);
  ctx.restore();
}

// ── 模式：螺旋结构 ──
function drawSpiral() {
  const layers = 6;
  const baseR = 40;
  const gap = 48;

  // 旋转的背景辉光
  for (let l = layers; l >= 1; l--) {
    const r = baseR + (l - 1) * gap;
    const alpha = 0.03 + l * 0.01;
    const hue = 200 + l * 10;
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.strokeStyle = `hsl(${hue}, 60%, 60%)`;
    ctx.lineWidth = gap * 0.8;
    ctx.beginPath();
    ctx.arc(cx, cy, r, 0, Math.PI * 2);
    ctx.stroke();
    ctx.restore();
  }

  // 每一层的圆圈和权重标注
  for (let l = 1; l <= layers; l++) {
    const r = baseR + (l - 1) * gap;
    const alpha = 0.2 + l * 0.1;
    const weight = Math.pow(4, l - 1);
    const col = `hsl(${200 + l * 15}, 60%, ${40 + l * 5}%)`;

    circle(cx, cy, r, col, false, alpha);

    // 在圆上画4个点（α β γ θ）
    const labels = ['α', 'β', 'γ', 'θ'];
    for (let i = 0; i < 4; i++) {
      const angle = (i / 4) * Math.PI * 2 - Math.PI / 2 + t * 0.2 / l;
      const px = cx + r * Math.cos(angle);
      const py = cy + r * Math.sin(angle);
      circle(px, py, 3, col, true, alpha + 0.3);
      if (l <= 3) {
        text(labels[i], px + 8, py + 4, col, 9);
      }
    }

    // 权重标注
    if (l <= 5) {
      const labelX = cx + r + 10;
      const labelY = cy - 4;
      text(`w(${l})=${weight}`, labelX, labelY, `hsl(${200 + l * 15}, 40%, 55%)`, 9, 'left');
    }
  }

  // 折线从内向外
  ctx.save();
  ctx.strokeStyle = '#4488ff';
  ctx.lineWidth = 1.5;
  ctx.globalAlpha = 0.7;
  ctx.setLineDash([4, 4]);
  ctx.beginPath();
  let prevX = cx, prevY = cy;
  for (let l = 1; l <= layers; l++) {
    const r = baseR + (l - 1) * gap;
    const angle = (l * 1.2 + t * 0.3) % (Math.PI * 2);
    const px = cx + r * Math.cos(angle);
    const py = cy + r * Math.sin(angle);
    ctx.lineTo(px, py);
  }
  ctx.stroke();
  ctx.restore();

  // 箭头向内（回归）
  const arrowR = baseR + 4 * gap;
  const arrowAngle = -Math.PI / 4 + t * 0.1;
  const ax = cx + arrowR * Math.cos(arrowAngle);
  const ay = cy + arrowR * Math.sin(arrowAngle);
  const ax2 = cx + (arrowR - 30) * Math.cos(arrowAngle + 0.2);
  const ay2 = cy + (arrowR - 30) * Math.sin(arrowAngle + 0.2);
  line(ax, ay, ax2, ay2, '#44ffaa', 1.5, 0.6);

  // 标注
  text('外层（权重大）', cx, cy - baseR - 4 * gap - 20, '#888', 11);
  text('内层（权重小）', cx, cy + baseR + 16, '#888', 11);
  text('回归 ←', ax - 30, ay - 10, '#44ffaa', 10);
  text('折线向外：显化', cx + 120, cy - 20, '#4488ff', 10, 'left');

  // 零的说明（中心）
  circle(cx, cy, 6, '#44ffaa', true, 0.8);
  text('零（对称类）', cx + 14, cy + 4, '#44ffaa', 10, 'left');
}

// ── 模式：镜像结构 ──
function drawMirror() {
  const mirrorY = cy;
  const halfH = H * 0.35;

  // 镜面
  ctx.save();
  ctx.strokeStyle = '#ffffff';
  ctx.lineWidth = 1;
  ctx.globalAlpha = 0.3;
  ctx.setLineDash([8, 4]);
  ctx.beginPath();
  ctx.moveTo(cx - 300, mirrorY);
  ctx.lineTo(cx + 300, mirrorY);
  ctx.stroke();
  ctx.restore();

  text('镜面', cx + 310, mirrorY + 4, '#555', 11, 'left');

  // 镜外（上方）- 螺旋
  const layers = 5;
  const baseR = 30;
  const gap = 32;

  for (let l = 1; l <= layers; l++) {
    const r = baseR + (l - 1) * gap;
    const y = mirrorY - r * 0.6;
    const alpha = 0.15 + l * 0.08;
    circle(cx, mirrorY - halfH / 2, r, '#4488ff', false, alpha * 0.5);
  }

  // 镜外折线
  ctx.save();
  ctx.strokeStyle = '#4488ff';
  ctx.lineWidth = 2;
  ctx.globalAlpha = 0.8;
  ctx.beginPath();
  const extPoints = [[cx, mirrorY], [cx - 40, mirrorY - 60], [cx + 20, mirrorY - 110], [cx - 30, mirrorY - 160], [cx + 10, mirrorY - 210]];
  extPoints.forEach(([x, y], i) => {
    if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
  });
  ctx.stroke();
  ctx.restore();

  // 镜内折线（反射）
  ctx.save();
  ctx.strokeStyle = '#ff4466';
  ctx.lineWidth = 2;
  ctx.globalAlpha = 0.8;
  ctx.beginPath();
  extPoints.forEach(([x, y], i) => {
    const ry = 2 * mirrorY - y;
    if (i === 0) ctx.moveTo(x, ry); else ctx.lineTo(x, ry);
  });
  ctx.stroke();
  ctx.restore();

  // 节点标注
  extPoints.forEach(([x, y], i) => {
    if (i === 0) return;
    const labels = ['', 'α', 'β', 'γ', 'θ'];
    const ry = 2 * mirrorY - y;

    // 外（蓝）
    circle(x, y, 4, '#4488ff', true, 0.9);
    text(labels[i], x + 10, y, '#4488ff', 10, 'left');

    // 内（红）
    circle(x, ry, 4, '#ff4466', true, 0.9);
    text(labels[i], x + 10, ry, '#ff4466', 10, 'left');

    // 连接线
    line(x, y, x, ry, '#555', 0.5, 0.3);
  });

  // 标注区域
  text('镜外（正）', cx - 280, mirrorY - 40, '#4488ff', 12, 'left');
  text('镜内（负）', cx - 280, mirrorY + 50, '#ff4466', 12, 'left');

  // 镜面标注
  circle(cx, mirrorY, 6, '#ffffff', true, 0.5);
  text('镜', cx + 12, mirrorY + 4, '#aaa', 11, 'left');
}

// ── 模式：零的对称性 ──
function drawZero() {
  // 多个"零"的代表元
  const zeros = [
    { angle: 0, r: 0, label: 'α→α→α...', desc: '全α对称' },
    { angle: Math.PI * 2 / 5, r: 120, label: 'β→β→β...', desc: '全β对称' },
    { angle: Math.PI * 4 / 5, r: 120, label: 'γ→γ→γ...', desc: '全γ对称' },
    { angle: Math.PI * 6 / 5, r: 120, label: 'θ→θ→θ...', desc: '全θ对称' },
    { angle: Math.PI * 8 / 5, r: 120, label: 'α→β→α→β...', desc: '交替对称' },
  ];

  // 连接线（都是零）
  zeros.slice(1).forEach(z => {
    const x = cx + z.r * Math.cos(z.angle + t * 0.1);
    const y = cy + z.r * Math.sin(z.angle + t * 0.1);
    line(cx, cy, x, y, '#44ffaa', 0.5, 0.2);
  });

  // 外圈旋转的零
  zeros.slice(1).forEach(z => {
    const x = cx + z.r * Math.cos(z.angle + t * 0.1);
    const y = cy + z.r * Math.sin(z.angle + t * 0.1);

    ctx.save();
    ctx.globalAlpha = 0.6 + Math.sin(t + z.angle) * 0.2;
    circle(x, y, 20, '#44ffaa33', true);
    circle(x, y, 20, '#44ffaa', false);
    ctx.restore();

    text(z.label, x, y - 4, '#44ffaa', 9);
    text(z.desc, x, y + 10, '#446655', 8);
  });

  // 中心的零（等价类的代表）
  ctx.save();
  const pulse = 1 + Math.sin(t * 2) * 0.1;
  ctx.globalAlpha = 0.9;
  circle(cx, cy, 30 * pulse, '#44ffaa22', true);
  circle(cx, cy, 30 * pulse, '#44ffaa', false);
  text('[零]', cx, cy - 4, '#44ffaa', 14);
  text('等价类', cx, cy + 12, '#44ffaa', 9);
  ctx.restore();

  // 说明文字
  text('零 = 所有对称折线的等价类', cx, cy - 180, '#888', 12);
  text('无穷多个表示，同一个零', cx, cy - 162, '#666', 10);

  // 旋转箭头
  const arR = 160;
  const arA = t * 0.15;
  const arX = cx + arR * Math.cos(arA);
  const arY = cy + arR * Math.sin(arA);
  const arX2 = cx + arR * Math.cos(arA + 0.4);
  const arY2 = cy + arR * Math.sin(arA + 0.4);
  line(arX, arY, arX2, arY2, '#44ffaa44', 1.5);
  text('旋转不改变等价类', arX2 + 10, arY2, '#446655', 9, 'left');
}

// ── 模式：一个数的折线 ──
function drawNumber() {
  const layers = 7;
  const baseR = 40;
  const gap = 44;

  // 痣模式：○ ● ○ ● ○ ● ○
  const moles = [false, true, false, true, false, true, false];
  const labels = ['α', 'β', 'γ', 'θ', 'β', 'γ', 'α'];

  // 画每一层的圆
  for (let l = 1; l <= layers; l++) {
    const r = baseR + (l - 1) * gap;
    const hasMole = moles[l - 1];
    const col = hasMole ? '#ffaa44' : '#4488ff';
    circle(cx, cy, r, col, false, 0.15);
  }

  // 折线路径
  const points = [];
  for (let l = 1; l <= layers; l++) {
    const r = baseR + (l - 1) * gap;
    const hasMole = moles[l - 1];
    const baseAngle = hasMole ? Math.PI * 1.2 : Math.PI * 0.3;
    const angle = baseAngle + (l - 1) * 0.5;
    points.push({
      x: cx + r * Math.cos(angle),
      y: cy + r * Math.sin(angle),
      mole: hasMole,
      label: labels[l - 1],
      r, l
    });
  }

  // 画折线（蓝色）
  ctx.save();
  ctx.strokeStyle = '#4488ff';
  ctx.lineWidth = 1.5;
  ctx.globalAlpha = 0.5;
  ctx.setLineDash([3, 3]);
  ctx.beginPath();
  ctx.moveTo(cx, cy);
  points.forEach(p => ctx.lineTo(p.x, p.y));
  ctx.stroke();
  ctx.restore();

  // 画每个节点
  points.forEach(p => {
    const col = p.mole ? '#ffaa44' : '#4488ff';
    const r = p.mole ? 8 : 5;
    circle(p.x, p.y, r, col, true, 0.9);

    if (p.mole) {
      // 痣的标注
      text('●', p.x, p.y + 4, '#ffaa44', 10);
      text(`w=${Math.pow(4, p.l - 1)}`, p.x + 12, p.y - 8, '#ffaa44', 9, 'left');
    } else {
      text('○', p.x, p.y + 4, '#4488ff', 10);
    }
    text(p.label, p.x - 12, p.y + 4, '#666', 9);
  });

  // 数值计算
  const value = moles.reduce((sum, m, i) => m ? sum + Math.pow(4, i) : sum, 0);

  text('折线与最近零的距离 = Σ w(i)×●(i)', cx, cy - baseR - 5 * gap - 30, '#888', 11);
  text(`= ${moles.map((m, i) => m ? Math.pow(4, i) : 0).filter(v => v > 0).join(' + ')}`, cx, cy - baseR - 5 * gap - 12, '#aaa', 11);
  text(`= ${value}`, cx, cy - baseR - 5 * gap + 6, '#ffaa44', 13);
  text('痣 = 镜内大于镜外的层', cx, cy - baseR - 5 * gap + 24, '#666', 9);

  // 最近零
  circle(cx, cy, 5, '#44ffaa', true, 0.8);
  text('最近零（参考）', cx + 10, cy + 4, '#44ffaa', 9, 'left');
}

// ── 模式：等价类旋转 ──
function drawEquiv() {
  const r = 130;
  const numRep = 6;

  // 等价类的多个代表元（镜内外成对同时旋转）
  for (let i = 0; i < numRep; i++) {
    const angle = (i / numRep) * Math.PI * 2 + t * 0.2;
    const x = cx + r * Math.cos(angle);
    const y = cy + r * Math.sin(angle);
    const alpha = 0.4 + 0.4 * Math.abs(Math.cos(angle));

    ctx.save();
    ctx.globalAlpha = alpha;

    // 镜外折线（蓝）
    ctx.strokeStyle = '#4488ff';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    for (let l = 0; l < 4; l++) {
      const lr = 10 + l * 10;
      const la = angle + l * 0.6;
      const lx = x + lr * Math.cos(la);
      const ly = y + lr * Math.sin(la);
      if (l === 0) ctx.moveTo(x, y); else ctx.lineTo(lx, ly);
    }
    ctx.stroke();

    // 镜内折线（红，对称）
    ctx.strokeStyle = '#ff4466';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    for (let l = 0; l < 4; l++) {
      const lr = 10 + l * 10;
      const la = angle - l * 0.6; // 对称方向
      const lx = x + lr * Math.cos(la);
      const ly = y + lr * Math.sin(la);
      if (l === 0) ctx.moveTo(x, y); else ctx.lineTo(lx, ly);
    }
    ctx.stroke();

    circle(x, y, 4, '#aaaaaa', true);
    ctx.restore();
  }

  text('蓝=镜外  红=镜内  同步旋转', cx, cy + 170, '#555', 9);

  // 旋转箭头（大圆）
  ctx.save();
  ctx.strokeStyle = '#ffffff';
  ctx.lineWidth = 0.5;
  ctx.globalAlpha = 0.1;
  ctx.setLineDash([4, 6]);
  ctx.beginPath();
  ctx.arc(cx, cy, r, 0, Math.PI * 2);
  ctx.stroke();
  ctx.restore();

  // 中心等价类标识
  ctx.save();
  const pulse = 1 + Math.sin(t * 1.5) * 0.08;
  circle(cx, cy, 50 * pulse, '#ffffff08', true);
  circle(cx, cy, 50 * pulse, '#ffffff22', false);
  text('[x]', cx, cy - 6, '#ddd', 18);
  text('等价类', cx, cy + 14, '#888', 10);
  ctx.restore();

  // 数值不变说明
  text('镜内外同时旋转 → 相对关系不变', cx, cy - 200, '#888', 12);
  text('所有代表元属于同一等价类', cx, cy - 180, '#666', 10);

  // 旋转角度示意
  const rAngle = t * 0.2;
  const r1x = cx + r * Math.cos(rAngle);
  const r1y = cy + r * Math.sin(rAngle);
  const r2x = cx + r * Math.cos(rAngle + 1.0);
  const r2y = cy + r * Math.sin(rAngle + 1.0);
  ctx.save();
  ctx.strokeStyle = '#ffaa44';
  ctx.lineWidth = 1;
  ctx.globalAlpha = 0.5;
  ctx.beginPath();
  ctx.arc(cx, cy, r, rAngle, rAngle + 1.0);
  ctx.stroke();
  ctx.restore();
  text('θ', (r1x + r2x) / 2 + 10, (r1y + r2y) / 2, '#ffaa44', 11);

  // 等价关系公式
  text('(L外, L内) ~ (L\'外, L\'内)', cx, cy + 220, '#555', 10);
  text('⟺ ∃θ: 旋转θ后重合', cx, cy + 238, '#555', 10);

  // 压岁钱比喻
  text('就像压岁钱流通', cx + 220, cy, '#444', 10, 'left');
  text('形式变，本质不变', cx + 220, cy + 16, '#444', 10, 'left');
}

// ── 主循环 ──
function draw() {
  clear();
  t += 0.016;

  switch (mode) {
    case 'spiral': drawSpiral(); break;
    case 'mirror': drawMirror(); break;
    case 'zero': drawZero(); break;
    case 'number': drawNumber(); break;
    case 'equiv': drawEquiv(); break;
  }

  animId = requestAnimationFrame(draw);
}

// 鼠标交互
let mouseX = cx, mouseY = cy;
canvas.addEventListener('mousemove', e => {
  mouseX = e.clientX;
  mouseY = e.clientY;
});

updateInfo('spiral');
draw();
</script>
</body>
</html>
